import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,o as e,d as n}from"./app-l65TvXU-.js";const o={},p=n('<h2 id="" tabindex="-1"><a class="header-anchor" href="#"><span></span></a></h2><p><strong>为什么容量必须是 2 的次幂</strong></p><ol><li><p><strong>索引计算高效</strong>：通过 hash &amp; (capacity - 1) 快速计算索引，替代取模操作。在计算机中，位运算的速度要远高于取余运算，因为计算机本质上就是二进制嘛。</p></li><li><p><strong>扩容高效</strong>：容量翻倍时，仅通过简单的位运算 hash &amp; (newCapacity - 1) 即可判断元素位置，无需重新计算所有索引。</p></li><li><p><strong>冲突率低</strong>：当容量是 2 的次幂时，hash &amp; (capacity - 1) 保留了哈希值的低位特征，能均匀分布索引。若容量不是 2 的次幂，低位特征无法有效参与索引计算，可能导致大量冲突。</p></li><li><p><strong>实现简单</strong>：避免复杂的对齐计算。</p></li></ol><p>链表树化的条件由两部分组成：</p><ol><li><p>插入时链表长度达到 &gt;= 8，调用 treeifyBin。</p></li><li><p>treeifyBin 方法中，数组长度必须 &gt;= 64 才真正树化，否则会优先扩容。</p></li></ol>',5),i=[p];function r(s,l){return e(),a("div",null,i)}const g=t(o,[["render",r],["__file","hashmap.html.vue"]]),m=JSON.parse('{"path":"/docs/code/backend/java/hashmap.html","title":"HashMap面经常见问题","lang":"zh-CN","frontmatter":{"title":"HashMap面经常见问题","icon":"file","order":null,"date":"2024-12-17T00:00:00.000Z","category":["Java"],"tags":["面经"],"description":"为什么容量必须是 2 的次幂 索引计算高效：通过 hash & (capacity - 1) 快速计算索引，替代取模操作。在计算机中，位运算的速度要远高于取余运算，因为计算机本质上就是二进制嘛。 扩容高效：容量翻倍时，仅通过简单的位运算 hash & (newCapacity - 1) 即可判断元素位置，无需重新计算所有索引。 冲突率低：当容量是 2 ...","head":[["meta",{"property":"og:url","content":"https://blueboysalvat.github.io/docs/code/backend/java/hashmap.html"}],["meta",{"property":"og:site_name","content":"忧郁男孩的救赎"}],["meta",{"property":"og:title","content":"HashMap面经常见问题"}],["meta",{"property":"og:description","content":"为什么容量必须是 2 的次幂 索引计算高效：通过 hash & (capacity - 1) 快速计算索引，替代取模操作。在计算机中，位运算的速度要远高于取余运算，因为计算机本质上就是二进制嘛。 扩容高效：容量翻倍时，仅通过简单的位运算 hash & (newCapacity - 1) 即可判断元素位置，无需重新计算所有索引。 冲突率低：当容量是 2 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"WangWenpeng"}],["meta",{"property":"article:tag","content":"面经"}],["meta",{"property":"article:published_time","content":"2024-12-17T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"HashMap面经常见问题\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-12-17T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"WangWenpeng\\",\\"url\\":\\"blueboysalvat.github.io\\"}]}"]]},"headers":[{"level":2,"title":"","slug":"","link":"#","children":[]}],"git":{},"readingTime":{"minutes":0.87,"words":260},"filePathRelative":"docs/code/backend/java/hashmap.md","localizedDate":"2024年12月17日","excerpt":"<h2></h2>\\n<p><strong>为什么容量必须是 2 的次幂</strong></p>\\n<ol>\\n<li>\\n<p><strong>索引计算高效</strong>：通过 hash &amp; (capacity - 1) 快速计算索引，替代取模操作。在计算机中，位运算的速度要远高于取余运算，因为计算机本质上就是二进制嘛。</p>\\n</li>\\n<li>\\n<p><strong>扩容高效</strong>：容量翻倍时，仅通过简单的位运算 hash &amp; (newCapacity - 1) 即可判断元素位置，无需重新计算所有索引。</p>\\n</li>\\n<li>\\n<p><strong>冲突率低</strong>：当容量是 2 的次幂时，hash &amp; (capacity - 1) 保留了哈希值的低位特征，能均匀分布索引。若容量不是 2 的次幂，低位特征无法有效参与索引计算，可能导致大量冲突。</p>\\n</li>\\n<li>\\n<p><strong>实现简单</strong>：避免复杂的对齐计算。</p>\\n</li>\\n</ol>","autoDesc":true}');export{g as comp,m as data};
