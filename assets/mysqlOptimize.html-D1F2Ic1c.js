import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,o as l,d as i}from"./app-l65TvXU-.js";const n={},o=i('<h2 id="覆盖索引" tabindex="-1"><a class="header-anchor" href="#覆盖索引"><span>覆盖索引</span></a></h2><blockquote><p>查询的列要被所建的索引覆盖到</p></blockquote><p>为了避免回表查询，导致的不必要的性能损耗。</p><p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p><h2 id="索引设计原则" tabindex="-1"><a class="header-anchor" href="#索引设计原则"><span>索引设计原则</span></a></h2><ul><li><p>针对于数据量较大，且查询比较频繁的表建立索引。</p></li><li><p>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</p></li><li><p>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</p></li><li><p>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</p></li><li><p>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</p></li><li><p>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</p></li><li><p>如果索引列不能存储 NULL 值，请在创建表时使用 NOT NULL 约束它。当优化器知道每列是否包含 NULL 值时，它可以更好地确定哪个索引最有效地用于查询。</p></li></ul><h2 id="索引失效的情况" tabindex="-1"><a class="header-anchor" href="#索引失效的情况"><span>索引失效的情况</span></a></h2><ul><li>用 or 分割开的条件，如果 or 前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。当 or 连接的条件，左右两侧字段都有索引时，索引才会生效。</li><li>没有遵守最左前缀法则，使用条件时第一个条件不是联合索引的第一个字段；如果使用的联合索引的开头但是条件中跳过了联合索引的部分字段，则从断开处后面的索引失效。</li><li>计算、函数、类型转换（自动 or 手动，如果字符串不加单引号，对于查询结果，没什么影响，但是数据库存在隐式类型转换，索引将失效），会导致索引失效而转向全表扫描</li><li>使用 like 模糊查询时，如果查询的关键字以%开头，则索引失效，以%结尾没事。</li><li>mysql 在使用不等于(!= 或者&lt;&gt;)的时候无法使用索引会导致全表扫描；业务允许的情况下尽量使用&gt;=</li><li>is null，is not null 也无法使用索引</li></ul>',8),p=[o];function a(r,s){return l(),t("div",null,p)}const h=e(n,[["render",a],["__file","mysqlOptimize.html.vue"]]),m=JSON.parse('{"path":"/docs/code/database/mysqlOptimize.html","title":"Mysql数据库优化","lang":"zh-CN","frontmatter":{"title":"Mysql数据库优化","icon":"file","order":null,"date":"2024-04-27T00:00:00.000Z","category":["Java"],"tags":["Mysql"],"description":"覆盖索引 查询的列要被所建的索引覆盖到 为了避免回表查询，导致的不必要的性能损耗。 在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。 索引设计原则 针对于数据量较大，且查询比较频繁的表建立索引。 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。 ...","head":[["meta",{"property":"og:url","content":"https://blueboysalvat.github.io/docs/code/database/mysqlOptimize.html"}],["meta",{"property":"og:site_name","content":"忧郁男孩的救赎"}],["meta",{"property":"og:title","content":"Mysql数据库优化"}],["meta",{"property":"og:description","content":"覆盖索引 查询的列要被所建的索引覆盖到 为了避免回表查询，导致的不必要的性能损耗。 在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。 索引设计原则 针对于数据量较大，且查询比较频繁的表建立索引。 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"WangWenpeng"}],["meta",{"property":"article:tag","content":"Mysql"}],["meta",{"property":"article:published_time","content":"2024-04-27T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Mysql数据库优化\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-04-27T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"WangWenpeng\\",\\"url\\":\\"blueboysalvat.github.io\\"}]}"]]},"headers":[{"level":2,"title":"覆盖索引","slug":"覆盖索引","link":"#覆盖索引","children":[]},{"level":2,"title":"索引设计原则","slug":"索引设计原则","link":"#索引设计原则","children":[]},{"level":2,"title":"索引失效的情况","slug":"索引失效的情况","link":"#索引失效的情况","children":[]}],"git":{},"readingTime":{"minutes":2.22,"words":665},"filePathRelative":"docs/code/database/mysqlOptimize.md","localizedDate":"2024年4月27日","excerpt":"<h2>覆盖索引</h2>\\n<blockquote>\\n<p>查询的列要被所建的索引覆盖到</p>\\n</blockquote>\\n<p>为了避免回表查询，导致的不必要的性能损耗。</p>\\n<p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p>\\n<h2>索引设计原则</h2>\\n<ul>\\n<li>\\n<p>针对于数据量较大，且查询比较频繁的表建立索引。</p>\\n</li>\\n<li>\\n<p>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</p>\\n</li>\\n<li>\\n<p>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</p>\\n</li>\\n<li>\\n<p>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</p>\\n</li>\\n<li>\\n<p>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</p>\\n</li>\\n<li>\\n<p>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</p>\\n</li>\\n<li>\\n<p>如果索引列不能存储 NULL 值，请在创建表时使用 NOT NULL 约束它。当优化器知道每列是否包含 NULL 值时，它可以更好地确定哪个索引最有效地用于查询。</p>\\n</li>\\n</ul>","autoDesc":true}');export{h as comp,m as data};
